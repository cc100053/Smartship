# Q&A

## 1. Why using these tech-stack to build this project?
（なぜこの技術スタックを選定したのですか？）

このプロジェクト（SmartShip）では、日本の物流システム特有の複雑さと、高度な3Dパッキング計算を両立させるために、以下の技術スタックを選定しました。

### Backend: Spring Boot 3 (Java 21)
**選定理由: 「計算力」と「堅牢性」**

このシステムの核心は、商品の回転（`.withRotate3D()`）や配置順序の組み合わせを総当たりで検証する「Brute Force 3D Packing」アルゴリズムです。
*   **計算能力:** 多数のアイテムを扱う際の指数関数的な計算負荷に耐え、ミリ秒単位で結果を返すために、コンパイル言語でありパフォーマンスに優れたJavaを採用しました。
*   **信頼性:** 20種類以上の配送キャリア（ネコポス、ゆうパック等）の複雑なサイズ・重量制限ルールを型安全に管理するため、Spring Bootの強力なDI（依存性注入）とアーキテクチャを活用しています。

### Frontend: React 19 + Vite + Tailwind CSS
**選定理由: 「軽量な3D可視化」と「開発速度」**

ユーザーに「なぜこの箱なのか」を直感的に伝えるための3Dビジュアライザーが必要でした。
*   **軽量3D:** ブラウザで手軽に3D表現を行うために、Reactのエコシステムと親和性が高い「React Three Fiber (Three.js)」を採用しました。宣言的なコードで3Dシーンを構築でき、コンポーネント指向のReactと組み合わせることで、効率的に実装しています。
*   **デザイン:** 複雑な料金比較表やフォームを、美しくレスポンシブに構築するためにTailwind CSSを採用しました。

### Database: Supabase (PostgreSQL)
**選定理由: 「データ整合性」と「立ち上げの速さ」**

*   配送サービスの料金体系や寸法制限は頻繁に変更される可能性があります。これらをリレーショナルデータとして厳格に管理しつつ、開発初期のスピードを最大化するために、PostgreSQLベースのBaaSであるSupabaseを採用しました。

## 2. Spring Bootの強力なDIとは？
**依存性注入（Dependency Injection）による、「疎結合」で「テスト容易」な設計のことです。**

通常のJava開発では `new PackingService()` のように自分でインスタンスを生成しますが、Spring Bootでは `@Service` や `@Component` をつけたクラスを自動的に管理（DIコンテナ）し、必要な場所（`ShippingController`）に自動で渡してくれます。

### 1. なぜこれが強力なのか？
このプロジェクト（SmartShip）では、配送計算ロジック（Service）と、それを使うWeb API（Controller）を明確に分離できています。
*   **柔軟な交換:** 例えば、将来的に「AIを使った新しい梱包アルゴリズム」を作った場合、Controllerのコードを一切変更することなく、DIの設定を変えるだけでアルゴリズムを差し替えることができます。
*   **テストの容易さ:** テスト時には本物の「Supabaseデータベース」や「3D計算処理」を使う代わりに、「モック（偽物）」を注入することができます。これにより、データベース接続なしでWeb APIの動作チェックが可能になります。

### 2. SmartShipでの具体例
`ShippingController.java` のコンストラクタを見てください。
```java
// ShippingController.java
public ShippingController(
        ProductRepository productRepository,    // データベース操作
        ShippingMatcher shippingMatcher,        // 料金比較ロジック
        PackingService packingService           // 3Dパッキング計算
    ) {
    this.productRepository = productRepository;
    this.shippingMatcher = shippingMatcher;
    this.packingService = packingService;
}
```
ここでは `new` キーワードを一度も使っていません。
Spring Bootが起動時に勝手に最適なインスタンス（`PackingService` など）を生成し、このコンストラクタに**注入（Inject）**してくれます。これにより、開発者は「オブジェクトの管理」から解放され、「ロジックの実装」に集中できます。

## 3. どうやって３Dのモデルを見せることができますか？
**React Three Fiber (R3F) というライブラリを使用して、Webブラウザ上に3D空間を描画しています。**

このプロジェクトでは、一般的な`<div>`などのHTML要素ではなく、`<Canvas>`という特殊なコンポーネントを使って3Dの世界（シーン）を作っています。

### 具体的な仕組み
`<ParcelVisualizer3D>` コンポーネントの中で、以下の手順で3D表示を行っています。

1.  **Canvasの設置:**
    画面上に3Dを描画するための領域 `<Canvas>` を配置します。これが3D世界の「窓」になります。

2.  **箱（ジオメトリ）の配置:**
    計算された配送箱や商品の寸法・位置情報をもとに、`<mesh>`（3Dオブジェクトの基本単位）と `<boxGeometry>`（直方体の形状）を使って3D空間に配置しています。
    *   `position`: 計算結果のx, y, z座標
    *   `args`: 箱の幅、高さ、奥行き
    これらをReactのpropsとして渡すことで、動的にパッキングの様子を再現しています。

3.  **カメラと照明:**
    ユーザーが見やすいように `<OrbitControls>` でマウス操作による視点移動（回転・拡大縮小）を可能にし、`<Environment>` や `<ambientLight>` で自然な光の反射を表現して、箱の立体感を強調しています。

もし、より複雑な商品モデル（フィギュアや特定の製品など）を表示させたい場合は、`.gltf` 形式などの3Dモデルファイルを読み込み、単純な `<boxGeometry>` の代わりに表示させることも可能です。

## 4. 外部ライブラリ（3d-bin-container-packingなど）はどうやって接続していますか？
**Javaのビルドツールである「Maven」を使用して、インターネット上のリポジトリから自動的にダウンロード・接続しています。**

このプロジェクトでは手動でjarファイルをダウンロードしたり、クラスパスを設定したりする必要はありません。`pom.xml` という設定ファイルに「これが欲しい」と書くだけで、Mavenがすべて管理してくれます。

### 具体的な接続方法
`backend/pom.xml` ファイルを見てください。以下のような記述があります。

```xml
<!-- backend/pom.xml -->
<dependency>
    <groupId>com.github.skjolber.3d-bin-container-packing</groupId>
    <artifactId>core</artifactId>
    <version>4.1.0</version>
</dependency>
```

### 仕組み
1.  **記述:** `pom.xml` の `<dependencies>` タグの中に、使いたいライブラリの `groupId`（発行者）、`artifactId`（ライブラリ名）、`version`（バージョン）を記述します。
2.  **自動取得:** プロジェクトをビルド（`mvnw install` や IDEでの再読み込み）すると、Mavenが「Maven Central Repository」などの公開サーバーから自動的にライブラリをダウンロードします。
3.  **利用:** ダウンロードされたライブラリは自動的にプロジェクトの「クラスパス」に追加され、Javaコード内で `import com.github.skjolber.packing...` のようにすぐに使えるようになります。

このように、Mavenを使うことで、複雑な外部ライブラリもわずか数行のXML記述だけでプロジェクトに統合（Connect）することができます。

## 5. 【一般観覧者向け】よく聞かれそうな質問

### Q1. メルカリ公式アプリと何が違うんですか？
**A. 「梱包前」にサイズがわかる点と、「複数商品の組み合わせ」計算ができる点が違います。**

メルカリ公式は出品時に「この配送方法が使えます」と教えてくれますが、実際に箱に入るかどうかは自分で試す必要があります。
SmartShipは、**手元にある箱や封筒に、この商品（とあの商品）が本当に入るのか？** を3Dでシミュレーションできるため、「パッキングしてからサイズオーバーで断られる」という事故を防げます。

### Q2. 3Dで見れるのは面白いですが、実用性はありますか？
**A. はい、「隙間に何が入るか」が直感的にわかるため、おまけ（同梱物）を入れる際に役立ちます。**

例えば「フィギュアの横に空いたこの隙間に、缶バッジなら3個入るな」といった判断が画面上でできます。これにより、送料を変えずに付加価値をつけて出品する「まとめ売り」の戦略が立てやすくなります。
また、「宅急便コンパクト（専用BOX）」のような特殊な形状の箱に対しても、ギリギリ入るかどうかの判定を厳密に行っています。

### Q3. 計算時間はどれくらいかかりますか？
**A. ほとんどの計算は0.1秒以内に終わります。**

商品が10個程度までなら一瞬で計算が終わります。これはJava（Spring Boot）という高速な言語を使っているためです。
商品の数が15個、20個と増えると計算の組み合わせが指数関数的に増えますが、その場合でも「2秒」で計算を打ち切って、その時点でのベストな解を返すように安全装置（タイムアウト処理）を入れていますので、アプリが固まることはありません。

### Q4. パッキングのロジックはどうなっているんですか？
**A. 「逆転の発想」で計算しています。商品が入る箱を探すのではなく、「安い箱から順に、商品が入るか試す」という総当り方式です。**

通常の人間は「この量だからこの箱かな？」と推測しますが、SmartShipは以下のように機械的に判定します。

1.  **箱のリストアップ:**
    まず、登録されている全ての配送方法（ネコポス、宅急便コンパクト、ゆうパック各サイズ…）を**「料金が安い順」**に並べます。

2.  **総当りチャレンジ:**
    一番安い箱（例: ネコポス ¥210）を選び、商品を詰め込もうとします。
    **★ここで外部ライブラリ（3d-bin-container-packing）が登場します！**
    ライブラリに「この箱のサイズ」と「商品のサイズ一覧」を渡すと、数千～数万通りの並べ方を高速に計算して「入る/入らない」を判定してくれます。
    *   **失敗:** 「厚さが20cmあるから3cmの箱には無理」→ 次の箱へ。
    *   **成功:** 「入った！」→ これが最安の候補になります。

### Q5. そのライブラリの主な役割は「並べ方の計算」ですか？
**A. その通りです。特に「回転」と「組み合わせ」の膨大な計算がメインの役割です。**

人間なら「この箱にこれを入れる」と直感で分かりますが、コンピュータの場合、以下のような膨大なパターンを全て試す必要があります。

1.  **3軸の回転:** 商品Aを「縦にするか？ 横にするか？ 立てるか？」 (3通り)
2.  **配置場所:** 商品Aを「右端に置くか？ 奥に置くか？ 上に積むか？」
3.  **入れる順番:** 商品A→Bの順か？ 商品B→Aの順か？

商品が5個あるだけでも、これらの組み合わせは数万通り以上になります。
このライブラリ（3d-bin-container-packing）は、**「Brute Force（総当り）」**という手法を使って、この数万通りのパターンを0.01秒レベルの超高速で検証し、「一番無駄なく入る並べ方」を見つけ出してくれます。

SmartShipのJavaコードは「ライブラリに商品を渡す係」であり、実際の「パズルの回答を見つける頭脳」はこのライブラリが担当しています。

3.  **最適解の選出:**
    入った箱の中で、さらに「追跡番号がついているか」「補償はあるか」などの条件を加味して、ユーザーに一番おすすめの配送方法を決定します。

この「箱ありき」のアプローチにより、どんなに複雑な形状の商品でも、物理的に箱に入るかどうかを正確に判定することができます。
