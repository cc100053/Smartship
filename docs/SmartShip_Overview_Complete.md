# SmartShip プロジェクト総合解説資料

このドキュメントは、SmartShipプロジェクトの「概要（プレゼン台本）」「システムアーキテクチャ」「技術的Q&A」を一つにまとめた総合資料です。

---

## 第1部：プロダクト概要（展示会用スクリプトより）

### 1. イントロデクション
「こんにちは。本日は配送最適化ツール『SmartShip』をご紹介します。」

### 2. 開発のきっかけ (Story)
このアプリを作ったきっかけは、私自身の日常生活の中での『気づき』でした。
私は普段からメルカリを愛用しており、頻繁に物を売ったり買ったりしている**ヘビーユーザー**です。
しかし、出品するたびに毎回悩まされることがありました。それは**『発送方法の選択』**です。

*   『この商品は厚さ3cm以内でいけるか？』
*   『重さは大丈夫か？』

少しでもサイズを間違えれば送料が高くなり、利益が減ってしまいます。

### 3. 課題と解決策 (Problem & Solution)
もちろん、既存の送料計算ツールも世の中には存在します。しかし、実際に使ってみると**使い心地があまり良くない**ものが多く、直感的に使えるものがありませんでした。

『ならば、自分で作ってしまおう』

そう考えて開発したのが、この**SmartShip**です。

### 4. プロダクトの特徴 (Features)
SmartShipの最大の特徴は、**『3D可視化』と『自動計算』**です。

ユーザーは商品をカートに入れるだけ。
バックエンドの強力なアルゴリズムが、数ある配送方法の中から**最も安く、最適なプラン**を瞬時に計算して提案します。

さらに、画面上の3Dビューで『実際に箱にどう詰めればいいか』を直感的に確認できるため、『なぜこのサイズなのか』という疑問をその場で解消できます。

### 5. 締め (Closing)
「日々の小さな問題を、技術の力で解決する。」
それがSmartShipです。ぜひ実際に体験してみてください。

---

## 第2部：システムアーキテクチャ詳細

このアプリケーションは、**Spring Boot (Backend)** と **React (Frontend)** という現代的なウェブ開発の標準的な構成（分離型構成）で作られています。

### 1. 全体構成
*   **Backend: Spring Boot 3 (Java 21)**
    *   **役割**: 重い計算（3Dパッキングアルゴリズム）、データベース操作、配送ルールの判定。
    *   **理由**: 総当たり（Brute-Force）で最適な箱詰めを計算するには、JavaScriptよりもJavaのようなコンパイル言語の方が高速で型安全だからです。
*   **Frontend: React 19 / Vite + Tailwind CSS**
    *   **役割**: 画面表示、3Dビジュアライゼーション、ユーザーインターフェース。
    *   **理由**: ユーザーが商品をカートに入れた瞬間に「どの箱になるか」を3Dで確認できる高いインタラクティブ性が必要なため、SPA（Single Page Application）として構築されています。
*   **Database: Supabase (PostgreSQL)**
    *   **役割**: 商品マスタ、配送データの管理。

### 2. Backend (Java) の詳細解説
場所: `backend/src/main/java/com/smartship/`

#### A. Controller (司令塔)
**ファイル**: `controller/ShippingController.java`
*   **仕事**: フロントエンドからのリクエスト（「この商品を計算して！」）を受け付けます。
*   **流れ**:
    1.  `calculateCart` メソッドが呼ばれる。
    2.  `PackingService` に「商品を3Dパッキングしてサイズを教えて」と依頼。
    3.  返ってきたサイズを元に、`ShippingMatcher` に「一番安い配送方法は？」と依頼。
    4.  結果をまとめてJSONでフロントエンドに返す。

#### B. Service (計算ロジック)
ここがこのアプリの**心臓部**です。

**ファイル**: `service/PackingService.java`
*   **仕事**: **「特定の箱」に商品が入るかどうか**の判定（`canFit`）や、詰め方のパズル計算（`calculatePackedResult`）を担当します。
*   **仕組み**: `3d-bin-container-packing` というライブラリを使い、総当たりで計算しています。
    *   **ポイント**:
        *   **Library First**: 基本的にはライブラリの強力なアルゴリズム（FastLargestAreaFitFirstなど）を使用し、「回転」や「配置順」を考慮した緻密な計算を行います。
        *   **Fallback Strategies**: 万が一計算が失敗した場合でも、単純な体積計算などで概算を出す機能を持っています。

**ファイル**: `service/ShippingMatcher.java`
*   **仕事**: **「安い箱から順に」**実際に商品が入るかを確認し、最適な配送業者を選定します。
    *   **ロジック**:
        1.  配送方法を料金が安い順（ネコポス → 宅急便コンパクト → …）に並び替える。
        2.  一つずつ `PackingService.canFit()` を呼び出し、入るかどうかを確かめる。
        3.  物理的に入るものの中で、追跡・補償などの条件を満たす最安のものを提案する。
    *   **工夫点**: 単に「使えません」と返すだけでなく、「なぜ安い方の便が使えないのか（例：厚さが1cmオーバーしたから）」という理由を生成し、UIに表示します。

### 3. Frontend (React) の詳細解説
場所: `frontend/src/`

#### A. Entry Point
**ファイル**: `App.jsx`
*   **仕事**: 全体のレイアウト。背景のアニメーション（`animate-blob`）や、スクロール管理を行っています。

#### B. 3D Visualization (3D表示)
**ファイル**: `components/ParcelVisualizer3D.jsx`
*   **仕事**: 計算結果をブラウザ上で3D表示します。
*   **技術**: `@react-three/fiber` (Three.jsのReactラッパー) を使用。
*   **座標変換**: Javaのライブラリ（Y軸が奥行き）と、Three.js（Z軸が奥行き）で座標系が違うため、`PlacedBox` コンポーネント内で座標の入れ替え（Translation）を行っています。
*   **工夫点**:
    *   **Reference Object**: タバコ箱やスマホなどの「比較対象」を隣に置くことで、サイズ感を直感的に分かるようにしています。
    *   **OrbitControls**: ユーザーがマウスでぐるぐる回せる機能を提供しています。

#### C. State Management
**ファイル**: `hooks/useCart.js`, `hooks/useShippingCalculator.js`
*   **仕事**: ユーザーの入力状態（カートの中身）を管理します。
*   **工夫点**: 画面をリロードしてもカートの中身が消えないように、`localStorage` に保存する仕組みが入っています。

---

## 第3部：技術Q&Aと深掘り

### 1. 技術スタックの選定理由
*   **Backend (Java)**:
    このシステムの核心は、商品の回転や配置順序を総当たりで検証する「Brute Force 3D Packing」です。多数のアイテムを扱う際の計算負荷に耐え、ミリ秒単位で結果を返すために、パフォーマンスに優れたJavaを採用しました。
*   **Frontend (React + R3F)**:
    ブラウザで手軽に3D表現を行うために、React Three Fiberを採用しました。コンポーネント指向で効率的に3Dシーンを構築できます。

### 2. Spring Bootの強力なDIとは？
**依存性注入（Dependency Injection）による、「疎結合」で「テスト容易」な設計のことです。**

SmartShipでは、配送計算ロジック（Service）とWeb API（Controller）を明確に分離しています。これにより、将来的に「AIを使った新しい梱包アルゴリズム」を作った場合でも、Controllerのコード変更なしでアルゴリズムを差し替えることができます。また、データベース接続なしでWeb APIのテストが可能になります。

### 3. どうやって3Dモデルを表示していますか？
**React Three Fiber (R3F) を使用して、Webブラウザ上の `<Canvas>` に描画しています。**

1.  **Canvasの設置**: 3D世界の「窓」を配置。
2.  **箱の配置**: 計算された寸法をもとに、`<mesh>` と `<boxGeometry>` で動的に箱を描画。
3.  **操作**: `<OrbitControls>` でユーザーがマウスで自由に視点を操作できるようにしています。

### 4. 外部ライブラリ（3d-bin-container-packing）の接続
**Javaのビルドツール「Maven」を使用しています。**
`pom.xml` に依存関係（dependency）を記述するだけで、インターネット上のリポジトリから自動的にライブラリをダウンロード・接続しています。手動でのjarファイル管理は不要です。

### 5. 3Dパッキングのロジック詳細
**「逆転の発想」で計算しています。**

商品が入る箱を探すのではなく、「安い箱から順に、商品が入るか試す」という総当り方式です。
1.  **箱のリストアップ**: 全ての配送方法を「料金が安い順」に並べます。
2.  **総当りチャレンジ**: 一番安い箱（例: ネコポス ¥210）を選び、商品を詰め込もうとします。
    *   **★ここで外部ライブラリが登場**: 数万通りの「回転」「配置場所」「順序」の組み合わせを高速に計算し、入るか入らないかを判定します。
3.  **最適解の選出**: 入った箱の中で、追跡・補償などの条件を加味してベストな配送方法を決定します。

### 6. 一般ユーザー向けのメリット
*   **Q. メルカリ公式との違いは？**
    *   A. 「梱包前」にサイズがわかる点と、「複数商品の組み合わせ」計算ができる点が違います。
*   **Q. 3Dって実用性あるの？**
    *   A. はい。「この隙間に何が入るか」が分かるので、おまけ（同梱物）を入れる判断や、まとめ売りの戦略に役立ちます。
*   **Q. 計算時間は？**
    *   A. ほとんど0.1秒以内です。商品数が多くてもタイムアウト処理で安全に結果を返します。
